import tkinter as tk
from tkinter import messagebox, font
import random
import json, re
from typing import NamedTuple
from dotenv import load_dotenv
from itertools import cycle
load_dotenv()

import google.generativeai as genai
import os
genai.configure(api_key=os.getenv("GEMINI_KEY"))
model = genai.GenerativeModel('gemini-1.5-flash')

class TicTacToe:
    def __init__(self, root):
        self.root = root
        self.root.title("Tic Tac Toe")
        self.display_label = tk.Label(self.root, text="Welcome to Tic Tac Toe!", font=('consolas', 20))
        self.display_label.grid(row=0, column=0, columnspan=3)
        self.buttons = [[None for _ in range(3)] for _ in range(3)]
        self.board = [' ' for _ in range(9)]
        self.current_winner = None
        self.player = 'X'
        self.bot = 'O'
        self.create_board()
        self.optimal_move_probability = 1
        self.root.after(1000, self.LLMmove)
        self.validprompt = ''
        self.LLMMoveList = []
        self.BotMoveList = []
        self.BothMoveList = []

    def create_board(self):
        for i in range(3):
            for j in range(3):
                button = tk.Button(self.root, text='', font=('consolas', 40), width=5, height=2,
                                   command=lambda i=i, j=j: self.on_button_click(i, j))
                button.grid(row=i+1, column=j)
                self.buttons[i][j] = button

    def on_button_click(self, i, j):
        if self.buttons[i][j]['text'] == '' and self.current_winner is None:
            self.buttons[i][j]['text'] = self.player
            self.board[i * 3 + j] = self.player
            if self.check_winner(self.player):
                self.current_winner = self.player
                messagebox.showinfo("Tic Tac Toe", "You win!")
                self.update_display("You win!")
            elif ' ' not in self.board:
                messagebox.showinfo("Tic Tac Toe", "It's a tie!")
                self.reset_game()
                self.update_display("It's a tie!")
            else:
                self.root.after(1000, self.bot_move)
                if self.check_winner('O'):
                    messagebox.showinfo("Tic Tac Toe", "Bot wins!")
                    self.reset_game()
                    self.update_display("Bot wins!")
                elif ' ' not in self.board:
                    messagebox.showinfo("Tic Tac Toe", "It's a tie!")
                    self.reset_game()
                    self.update_display("It's a tie!")

    tic_tac_toe_explanation = '''Tic-Tac-Toe is a two-player game played on a 3 by 3 grid. The first player uses X symbols, and the second player uses O symbols. Players take turns placing their symbols in an empty cell on the grid. The objective is to align three of your symbols either horizontally, vertically, or diagonally. The player who first aligns three of their symbols wins the game. Strategic placement is crucial; besides aiming to align their symbols, players must also block their opponent's potential alignments to avoid defeat.'''
    tic_tac_toe_format = '''The current state of the game is recorded in a specific format: each occupied location is delineated by a comma (','), and for each occupied location, the row number is listed first, followed by the column number, separated by a period ('.'). If no locations are occupied by a player, 'None' is noted. Both the row and column numbers start from 0, with the top left corner of the grid indicated by 0.0'''
    tic_tac_toe_loss = '''You will lose if the second player gets a combination of one of the following: [0.0, 0.1, 0.2], [1.0, 1.1, 1.2], [2.0, 2.1, 2.2], [0.0, 1.0, 2.0], [0.1, 1.1, 2.1], [0.2, 1.2, 2.2], [0.0, 1.1, 2.2], [2.0, 1.1, 0.2]. If your opponent could play a move to complete one of these combinations in their next turn, you must play it before them to block them.'''
    tic_tac_toe_role = '''You are an adept strategic player, aiming to win the game in the fewest moves possible. You are the first (second) player. What would be your next move?'''
    tic_tac_toe_json = '''Suggest your next move in the following JSON format: {"row": RowNumber, "column": ColumnNumber}. Do not include any additional commentary in your response. Replace RowNumber and ColumnNumber with the appropriate numbers for your move. Both RowNumber and ColumnNumber start at 0 (top left corner is {"row": 0, "column": 0}}'). The maximum value for RowNumber and ColumnNumber is 2, as the grid is 3 by 3.'''
    tic_tac_toe_invalid = '''Please note that your move will be considered invalid if your response does not follow the specified format, or if you provide a RowNumber or ColumnNumber that is out of the allowed range, or already occupied by a previous move. Making more than 3 invalid moves will result in disqualification.'''

    instructions = '''You are a bot playing a Tic-Tac-Toe game to the best of your ability. 
                    I will give you the available moves in a standard 3x3 Tic-Tac-Toe game. 
                    You play as X and you go first. Try to get three in a row. You can only play an available move. 
                    The grids are numbered 0 to 8, like a normal 3x3 tic-tac-toe game, where 0 is the top left corner and 8 is the bottom right corner. You must do your best to block your opponent.
                    Respond with: the integer number (move) which you want to play, and then reason (walk me through) why that is the best move. Once you have played a move, you cannot play it again (you cannot play a number that is NOT on the list of available moves I send you.)
                    responses must look like this sample: (number) because it is ....'''

    def LLMmove(self):
        LLMList = []
        BotList = []
        self.update_display("LLM is thinking...")
        available_moves = self.available_moves()
        for move in range(0,9):
            if move not in available_moves:
                if move in self.LLMMoveList:
                    x, y = int(move) // 3, int(move) % 3
                    LLMList.append(f'{x}.{y}')
                else:
                    x, y = int(move) // 3, int(move) % 3
                    BotList.append(f'{x}.{y}')
            
        tic_tac_toe_status = f'''The current state of the game is as follows: The locations occupied by the first player (you): {LLMList}. The locations occupied by the second player (your opponent): {BotList}'''

        if self.current_winner is None:
            prompt = f'{self.validprompt} {self.tic_tac_toe_explanation} {self.tic_tac_toe_format} {tic_tac_toe_status} {self.tic_tac_toe_loss} {self.tic_tac_toe_role} {self.tic_tac_toe_json} {self.tic_tac_toe_invalid}'
            print(prompt)
            gemini_response = model.generate_content(f'{prompt}').text
            gemini_response_clean = re.sub(r'```json|```', '', gemini_response).strip()
            print(gemini_response_clean)
            response = json.loads(gemini_response_clean)
            if int(response['row']) * 3 + int(response['column']) in available_moves:
                i, j = int(response['row']), int(response['column'])
                self.LLMMoveList.append(int(response['row']) * 3 + int(response['column']))
                self.update_display("LLM has made a move.")
                self.on_button_click(i, j)
                self.validprompt = ''
            else:
                self.validprompt = f'''Your previous response was '{{"row": {int(response['row'])}, â€œcolumn": {int(response['column'])}}}'. This move was deemed invalid for the following reason: 'Already Taken'. Please adjust accordingly. Here are the instructions again:'''
                self.LLMmove()

    def bot_move(self):
        self.update_display("Bot is thinking...")
        if self.current_winner is None:
            if random.random() < self.optimal_move_probability:
                moves = self.get_all_optimal_moves(self.board, self.bot, -float('inf'), float('inf'))
                move = random.choice(moves)
            else:
                move = random.choice(self.available_moves())
            self.board[move] = self.bot
            self.buttons[move // 3][move % 3]['text'] = self.bot
            if self.check_winner(self.bot):
                self.current_winner = self.bot
                messagebox.showinfo("Tic Tac Toe", "Bot wins!")
                self.update_display("Bot wins!")
        self.root.after(1000, self.LLMmove)
        self.update_display("Bot has made a move.")

    def available_moves(self):
        return [i for i, spot in enumerate(self.board) if spot == ' ']

    def check_winner(self, player):
        win_conditions = [
            [0, 1, 2], [3, 4, 5], [6, 7, 8],
            [0, 3, 6], [1, 4, 7], [2, 5, 8],
            [0, 4, 8], [2, 4, 6]
        ]
        for condition in win_conditions:
            if all(self.board[i] == player for i in condition):
                return True
        return False

    def minimax(self, state, player, alpha, beta):
        max_player = self.bot
        other_player = self.player if player == self.bot else self.bot

        if self.check_winner(other_player):
            return {'X': -1, 'O': 1}[other_player], None
        elif ' ' not in state:
            return 0, None

        if player == max_player:
            max_eval = -float('inf')
            best_move = None
            for move in self.available_moves():
                state[move] = player
                sim_eval = self.minimax(state, other_player, alpha, beta)[0]
                state[move] = ' '
                if sim_eval > max_eval:
                    max_eval = sim_eval
                    best_move = move
                alpha = max(alpha, sim_eval)
                if beta <= alpha:
                    break
            return max_eval, best_move
        else:
            min_eval = float('inf')
            best_move = None
            for move in self.available_moves():
                state[move] = player
                sim_eval = self.minimax(state, other_player, alpha, beta)[0]
                state[move] = ' '
                if sim_eval < min_eval:
                    min_eval = sim_eval
                    best_move = move
                beta = min(beta, sim_eval)
                if beta <= alpha:
                    break
            return min_eval, best_move

    def get_all_optimal_moves(self, state, player, alpha, beta):
        max_player = self.bot
        other_player = self.player if player == self.bot else self.bot
        optimal_moves = []

        if player == max_player:
            max_eval = -float('inf')
            for move in self.available_moves():
                state[move] = player
                sim_eval = self.minimax(state, other_player, alpha, beta)[0]
                state[move] = ' '
                if sim_eval > max_eval:
                    max_eval = sim_eval
                    optimal_moves = [move]
                elif sim_eval == max_eval:
                    optimal_moves.append(move)
                alpha = max(alpha, sim_eval)
                if beta <= alpha:
                    break
            return optimal_moves
        else:
            min_eval = float('inf')
            for move in self.available_moves():
                state[move] = player
                sim_eval = self.minimax(state, other_player, alpha, beta)[0]
                state[move] = ' '
                if sim_eval < min_eval:
                    min_eval = sim_eval
                    optimal_moves = [move]
                elif sim_eval == min_eval:
                    optimal_moves.append(move)
                beta = min(beta, sim_eval)
                if beta <= alpha:
                    break
            return optimal_moves

    def reset_game(self):
        self.board = [' ' for _ in range(9)]
        self.current_winner = None
        for i in range(3):
            for j in range(3):
                self.buttons[i][j]['text'] = ''

    def update_display(self, message):
        self.display_label['text'] = message

root = tk.Tk()
game = TicTacToe(root)
root.mainloop()
